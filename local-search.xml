<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>What is Sass?</title>
    <link href="/2023/09/19/20220822/"/>
    <url>/2023/09/19/20220822/</url>
    
    <content type="html"><![CDATA[<p>  我們可以想像一下…<br>假設你要洗衣服，你需要按洗衣機的觸控面板才能啟動。<br>Sass就像是你使用洗衣觸控面板功能，你的指令會轉化成洗衣機懂的語言，才能啟動洗衣機執行洗衣服。</p><p>🎇 <strong>Sass</strong>（英文全稱：<strong>S</strong>yntactically <strong>A</strong>wesome <strong>S</strong>tyle<strong>s</strong>heets），是一個開發的層疊樣式表語言。　<br>Sass是一個將指令碼解析成CSS的<a href="https://zh.wikipedia.org/zh-tw/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80"><strong>手稿語言</strong></a>，即SassScript。Sass包括兩套語法。<br>sass是舊版本，業界主流是scss。<br>最開始的語法叫做「縮排語法」，使用縮排來區分代碼塊，並且用換行將不同規則分隔開。<br>而較新的語法叫做「SCSS」，使用和CSS一樣的塊語法，即使用大括號將不同的規則分開，使用分號將具體的樣式分開。<br>通常情況下，這兩套語法通過.sass和.scss兩個<a href="https://zh.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%89%A9%E5%B1%95%E5%90%8D"><strong>副檔名</strong></a>區分開。</p><p><strong>🐥 關於 Sass 的更多資訊:</strong><br><a href="https://ithelp.ithome.com.tw/articles/10126703">https://ithelp.ithome.com.tw/articles/10126703</a></p><ul><li><p><strong>CSS 預處理器的由來</strong></p><p>  因為網路的普及以及人們對網站愈來愈高的期待，前端開發的守備範圍持續擴大，網站也變得愈來愈複雜。人們需要尋找「更有效率的 CSS 撰寫&#x2F;管理方式」，來避免上述種種問題。</p><p>  因此，就出現了「<strong>CSS 預處理器 (CSS Preprocessor)</strong> 」這樣的解決方案——它本身是 CSS 語法的擴充，讓開發者能夠處理抽象邏輯，例如變數、模組、與繼承等等。</p><p>  透過這種方式，開發者在自己的開發環境裡透過預處理器，「用類似程式語言的方式設定樣式」，要交接給瀏覽器時，再編譯成底層的 CSS 語言。</p><p>  目前流行的 CSS 預處理器有：</p><ul><li><a href="http://sass-lang.com/"><strong>Sass</strong></a>：是最早誕生的預處理器，源於 Ruby 社群，發展成熟，普及度高，與 Less 相互影響，持續演進中。</li><li><a href="http://lesscss.org/"><strong>Less</strong></a>：稍晚於 Sass，強調兼容性並且更容易上手，也擁有自己的支持社群，例如著名的 Twitter Bootstrap 採用了 Less。</li><li><a href="http://stylus-lang.com/"><strong>Stylus</strong></a>：本質上和 Less&#x2F;Sass 類似，只是更為 Node.js 社群量身打造。</li></ul><p>  🐥 不同工具之間大同小異，本質都在解決一樣的問題，只是各有各的側重點，只需要學會其中一種，基本上就可以理解要點。</p></li></ul><h3 id="Sass-中的-amp-是什麼"><a href="#Sass-中的-amp-是什麼" class="headerlink" title="Sass 中的 &amp; 是什麼 ?"></a>Sass 中的 <strong>&amp;</strong> 是什麼 ?</h3><p>“ &amp; “ 可以看作是串聯選擇器的連接符。<br>連接符引用父層選擇器作替代， &amp; 連接符會代替父層選擇器: <a>，然後使鏈結懸停並改變鏈接的顏色爲其他顏色。<br>“&amp;” 省下了重複撰寫的時間，但過於巢狀也會導致程式碼不好維護，盡量在三層內解決！</a></p><h5 id="基礎概念"><a href="#基礎概念" class="headerlink" title="基礎概念:"></a>基礎概念:</h5><p>在CSS中，要想給一個元素賦予一定的樣式，我們必須得先取到這個元素。那麼就得需要選擇器，通過選擇器來選擇指定元素，然後賦予所需的樣式。</p><p>而CSS選擇器有很多種，比如層次選擇器中的<code>後代選擇器</code>、<code>兄弟選擇器</code>、<code>通用兄弟選擇器</code>等。</p><p>而這些選擇器都通過元素與元素之間的關係來確定的，比如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> <span class="hljs-selector-class">.child</span> &#123;...&#125;<br><br></code></pre></td></tr></table></figure><p>除了這些選擇器，還有<code>偽類選擇器</code>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.ele</span><span class="hljs-selector-pseudo">:after</span>&#123;...&#125;<br><br></code></pre></td></tr></table></figure><p>有時候還有<code>多類選擇器</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.className1</span><span class="hljs-selector-class">.className2</span>&#123;...&#125;<br><br></code></pre></td></tr></table></figure><p>這些選擇器在CSS中都是基礎知識，很多同學對其來說並不陌生。今天要說的也不是選擇器如何用，而是想說說，如何在編寫代碼的時候，少寫選擇器，就能實現他們之間的依賴關係。</p><h5 id="引用父層選擇器-的連接符-amp"><a href="#引用父層選擇器-的連接符-amp" class="headerlink" title="引用父層選擇器 的連接符 &amp;"></a>引用父層選擇器 的連接符 <strong>&amp;</strong></h5><p>在CSS中，這種想法是無法實現的，但在Sass中，可以輕鬆的通過**連接符<code>&amp;</code>**來實現。</p><p>我們先來回憶一下，CSS中常見的一組樣式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/*頁面中鏈接的顏色*/</span><br><span class="hljs-selector-tag">a</span> &#123;<br>  clolor: <span class="hljs-number">#ff3366</span>; <br>&#125;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#cc0033</span>; <br>&#125;<br><span class="hljs-comment">/*主選單中鏈接的顏色*/</span><br><span class="hljs-selector-class">.nav-menu</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff668c</span>; <br>&#125;<br><span class="hljs-selector-class">.nav-menu</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff99b3</span>; <br>&#125;<br><span class="hljs-selector-class">.nav-menu</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.active</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff0040</span>; <br>&#125;<br><span class="hljs-comment">/*頁尾選單中鏈接的顏色*/</span><br><span class="hljs-selector-class">.footer-menu</span> <span class="hljs-selector-tag">a</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#ff1a53</span>; <br>&#125;<br><span class="hljs-selector-class">.footer-menu</span> <span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#cc0033</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>這是一組控制頁面鏈接顏色的樣式代碼，首先在樣式中定義了共通樣的連結文預設顏色，而主選單和頁尾選單中連結文預設顏色各不相同，我們需要通過類名<code>.nav-menu</code>和<code>.footer-menu</code>來覆蓋默認的樣式。</p><p>這樣我們在寫樣式的時候，在選擇器這一部分，我們都需要書寫相同的一個部分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sass">aa:hover<br></code></pre></td></tr></table></figure><p>或許你覺得這有什麼的，真是大驚小怪。但是，如果你的選擇器偏長，重複的代碼偏多，一定會影響您的開發速度，從而影響你的效率。</p><p>那麼在Sass中，通過**連接符<code>&amp;</code>**可以幫助我們避免這樣的問題，而且還可以實現一些其他的效果。</p><h5 id="與偽類的結合"><a href="#與偽類的結合" class="headerlink" title="與偽類的結合"></a>與偽類的結合</h5><p>偽類和偽元素在CSS中是常用的一種方式。</p><p>比如最常見的是連結網址的偽類或者說偽元素<code>:after</code>和<code>:before</code>的使用。</p><p>大家常看到的就是清除浮動的<code>clearfix</code>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:before</span>,<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<span class="hljs-attribute">display</span>:table;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">clear</span>:both;<span class="hljs-attribute">overflow</span>:hidden;<br>&#125;<br><span class="hljs-selector-class">.clearfix</span> &#123;<br>    *zoom: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那麼在Sass中，使用<code>&amp;</code>會變得更簡單，更方便：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sass">$lte-ie: true !default;<br><br>.clearfix &#123;<br>    @if $lte-ie &#123;<br>        *zoom: 1;<br>    &#125;<br><br>    &amp;:before,<br>    &amp;:after &#123;<br>        content: &quot;&quot;;<br>        display: table;<br>    &#125;<br>    &amp;:after &#123;<br>        clear: both;<br>        overflow: hidden;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>這個簡單的例子非常明確說明，在Sass中可以使用<code>&amp;</code>和偽元素、偽類配合使用，而且使用的方法非常簡單。就是用<code>&amp;</code>替代元素自身。</p><h5 id="多類選擇器-className1-className2在CSS中並不常見-主要因為在IE6中解析有所偏差-，但還是非常有用。"><a href="#多類選擇器-className1-className2在CSS中並不常見-主要因為在IE6中解析有所偏差-，但還是非常有用。" class="headerlink" title="多類選擇器.className1　.className2在CSS中並不常見(主要因為在IE6中解析有所偏差)，但還是非常有用。"></a>多類選擇器<code>.className1</code>　<code>.className2</code>在CSS中並不常見(主要因為在<code>IE6</code>中解析有所偏差)，但還是非常有用。</h5><p>比如說增加一個懸浮效果的時候，可以看到這樣的樣式代碼：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.mod</span><span class="hljs-selector-class">.on</span> &#123;<br>    <span class="hljs-attribute">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><p>那麼在Sass中，同樣可以使用<code>&amp;</code>來替代選擇器<code>.mod</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sass">.mod &#123;<br>    &amp;.on&#123;<br>        color: green;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>這裡需要特別的注意，<code>&amp;</code>和相連的類名之間不能有任何的空格，不然就會變成CSS選擇器中的後代選擇器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sass">.mod &#123;<br>    &amp; .on &#123;<br>        color: green;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>編譯出來的CSS就成了：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.mod</span> <span class="hljs-selector-class">.on</span> &#123;<br>  <span class="hljs-attribute">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Sass中還有同等效果的寫法是Sass的直接嵌套：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sass">.mod &#123;<br>.on &#123;<br>color: green;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="後代選擇器"><a href="#後代選擇器" class="headerlink" title="後代選擇器"></a>後代選擇器</h5><p>正如上面的示例所示，在Sass中可以通過Sass的層級嵌套來實現後代選擇器。嵌套的越深，層級越多：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sass">.nav-menu &#123;<br>li &#123;<br>a &#123;<br>color: green;<br>          &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.nav-menu</span> <span class="hljs-selector-tag">li</span> <span class="hljs-selector-tag">a</span> &#123;<br><span class="hljs-attribute">color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><p>看到這里大家或許會問，這跟<code>&amp;</code>有什麼關係呢？因為在選擇器前面加上<code>&amp;</code>符和不加上<code>&amp;</code>符將得到的效果是一樣。</p><p>但大家可能也碰到過，有時候在Sass先寫了子元素的效果，但還需要另一個地方來覆蓋，那麼<code>&amp;</code>將會起到大作用。</p><p>先來看一個簡單的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sass">a &#123;<br>color: red;<br>.nav-menu &amp;&#123;<br>    color: blue;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生成的CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span> &#123;<br><span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.nav-menu</span> <span class="hljs-selector-tag">a</span> &#123;<br><span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例非常簡單的說明了一切，<code>&amp;</code>在選擇器後面時的功能。但這裡需要特別的注意，<code>&amp;</code>寫在後面的，前面必須要有空格。不然Sass在編譯時將會報錯：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sass">Change detected to: test.scss<br>error test.scss (Line 78: Invalid CSS after &quot; .nav-menu&quot;: expected <br>&quot;&#123;&quot;, was &quot;&amp;&#123;&quot;<br>&quot;&amp;&quot; may only be used at the beginning of a compound selector.)<br></code></pre></td></tr></table></figure><p>綜合上面所述，我們回到文章最開頭的那段CSS代碼，我們只需要靈活的運用好<code>&amp;</code>，就可以輕鬆的完成：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs css">$<span class="hljs-attribute">color</span>: <span class="hljs-number">#444</span>;<br>$bg-<span class="hljs-attribute">color</span>: <span class="hljs-number">#f5f5f5</span>;<br>$link-<span class="hljs-attribute">color</span>: <span class="hljs-number">#f36</span>;<br><span class="hljs-selector-tag">a</span> &#123;<br>clolor: $link-color;<br><br>&amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">darken</span>($link-color, <span class="hljs-number">20%</span>);<br>&#125;<br><br>//<span class="hljs-selector-tag">Main</span> <span class="hljs-selector-tag">menu</span> Link <span class="hljs-attribute">Color</span><br><span class="hljs-selector-class">.nav-menu</span> &amp; &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">lighten</span>($link-color, <span class="hljs-number">10%</span>);<br><br>    &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>        <span class="hljs-attribute">color</span>: <span class="hljs-built_in">lighten</span>($link-color, <span class="hljs-number">20%</span>);<br>    &#125;<br><br>    &amp;<span class="hljs-selector-class">.active</span> &#123;<br>        <span class="hljs-attribute">color</span>: <span class="hljs-built_in">darken</span>($link-color, <span class="hljs-number">10%</span>);<br>    &#125;<br>&#125;<br><br>//<span class="hljs-selector-tag">Footer</span> <span class="hljs-selector-tag">menu</span> link <span class="hljs-attribute">color</span><br><span class="hljs-selector-class">.footer-menu</span> &amp; &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-built_in">darken</span>($link-color, <span class="hljs-number">5%</span>);<br><br>    &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>        <span class="hljs-attribute">color</span>: <span class="hljs-built_in">darken</span>($link-color, <span class="hljs-number">20%</span>);<br>    &#125;<br>&#125;<br><br>//<span class="hljs-selector-tag">Footer</span> <span class="hljs-selector-tag">menu</span> link <span class="hljs-attribute">color</span><br>    <span class="hljs-selector-class">.footer-menu</span> &amp; &#123;<br>        <span class="hljs-attribute">color</span>: <span class="hljs-built_in">darken</span>($link-color, <span class="hljs-number">5%</span>);<br><br>        &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>            <span class="hljs-attribute">color</span>: <span class="hljs-built_in">darken</span>($link-color, <span class="hljs-number">20%</span>);<br>        &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="相鄰兄弟選擇"><a href="#相鄰兄弟選擇" class="headerlink" title="相鄰兄弟選擇"></a>相鄰兄弟選擇</h5><p>在CSS選擇器中還有一種是相鄰兄弟選擇器。如：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">label</span> + <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p><code>input[type=&quot;text&quot;]</code>元素緊鄰<code>label</code>元素。</p><p>在Sass中，同樣可以使用<code>&amp;</code>符來替代其中某個元素：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sass">lable &#123;<br>color: green;<br>&amp; + input[type=&quot;text&quot;] &#123;<br>    border: 1px solid green;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>編譯CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">lable &#123;<br><span class="hljs-attribute">color</span>: green;<br>&#125;<br>lable + <span class="hljs-selector-tag">input</span><span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;text&quot;</span>]</span> &#123;<br><span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid green;<br>&#125;<br></code></pre></td></tr></table></figure><p>在這裡僅僅想通過這樣一個簡單的示例來演示<code>&amp;</code>在選擇器中所承載的對象，換句話說，就是<code>&amp;</code>替代的是哪一處元素。</p><p>這跟其所處的位置以及對應使用的選擇器符號很有關係。</p><h5 id="媒體查詢中的嵌套功能（-Nested-Rules-）"><a href="#媒體查詢中的嵌套功能（-Nested-Rules-）" class="headerlink" title="媒體查詢中的嵌套功能（ Nested Rules ）"></a>媒體查詢中的嵌套功能（ Nested Rules ）</h5><p>在Sass中，媒體查詢配合<code>&amp;</code>符，可以輕鬆的讓你管理幾個不同版式的樣式（方便管理不同斷點下的樣式），先來看一個簡單的示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sass">.main &#123;<br>float: left;<br>width: 45em;@media (max-width: 480px) &#123;<br>    &amp; &#123;<br>        float: none;<br>        width: 100%;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>編譯出來的CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.main</span> &#123;<br><span class="hljs-attribute">float</span>: left;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">45em</span>;<br>&#125;<br><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">480px</span>) &#123;<br><span class="hljs-selector-class">.main</span> &#123;<br><span class="hljs-attribute">float</span>: none;<br><span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>這樣在製作響應式設計的時候是不是變得非常的簡單，而且易於管理你的代碼。</p><p>不過除了上面種方式之外，我們還可以採用下面的方式與媒體查詢配合使用：</p> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.main</span> &#123;<br> <span class="hljs-attribute">float</span>: left;<br> <span class="hljs-attribute">width</span>: <span class="hljs-number">45em</span>;&amp; &#123;<br> <span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">480px</span>) &#123;<br>             <span class="hljs-attribute">float</span>: none;<br>         <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>     &#125;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>這段SCSS代碼編譯出來的CSS和前面的是一模一樣的。</p><h5 id="amp-符在Sass中存在的問題"><a href="#amp-符在Sass中存在的問題" class="headerlink" title="&amp; 符在Sass中存在的問題"></a><strong><code>&amp;</code></strong> 符在Sass中存在的問題</h5><p>前面主要演示了<code>&amp;</code>在Sass中如何讓你更好的使用您的選擇器，但是<code>&amp;</code>在Sass中運用也存在一些問題。接下來一起看看<code>&amp;</code>在Sass中存在的問題，以及如何避免這些問題。</p><p>說到這個問題，我們繼續拿CSS中的BEM來說事。</p><p>先簡單說明一下BEM的模式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.block</span>&#123;...&#125;<br><span class="hljs-selector-class">.block__element</span>&#123;...&#125;<br><span class="hljs-selector-class">.block--modifier</span>&#123;...&#125;<br></code></pre></td></tr></table></figure><p>很想在Sass中通過下面的方式實現BEM的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sass">.block&#123;<br>...<br>&amp;__element&#123;...&#125;<br>&amp;--modifier&#123;...&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可是這樣書寫，編譯器無法編譯，將會報出錯誤信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sass">Invalid CSS after &quot; &amp;&quot;: expected &quot;&#123;&quot;, was &quot;__element&#123;&quot;<br>&quot;__element&quot; may only be used at the beginning of a compound selector.)<br></code></pre></td></tr></table></figure><p>此時很多人有可能想到了使用Sass中的插件<code>#&#123;&amp;&#125;</code>的方式來替代<code>.block</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sass">.block&#123;<br>clolor: red;<br>#&#123;&amp;&#125;__element&#123;<br>color: green;<br>&#125;<br>#&#123;&amp;&#125;--modifier&#123;<br>color: blue;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但編譯出來的CSS代碼還是不盡人意：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.block</span> &#123;<br>clolor: red;<br>&#125;<br><span class="hljs-selector-class">.block</span> <span class="hljs-selector-class">.block__element</span> &#123;<br><span class="hljs-attribute">color</span>: green;<br>&#125;<br><span class="hljs-selector-class">.block</span> <span class="hljs-selector-class">.block--modifier</span> &#123;<br><span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>編譯出來的CSS代碼雖然有效，但並不是好的CSS代碼。</p><p>而且這樣編譯出來的CSS也離開了BEM的初衷。</p><p>這也是<code>&amp;</code>在Sass中當作插值使用不盡人意之處。</p><p>不過這種現像也有方法可以解決。</p><p>簡單一點的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs sass">$last-rule: null;<br>.block&#123;<br>clolor: red;<br>$last-rule: &amp;;<br>&#125;<br>#&#123;$last-rule&#125;__element&#123;<br>color: green;<br>&#125;<br>#&#123;$last-rule&#125;--modifier&#123;<br>color: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>編譯出來的CSS:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.block</span> &#123;<br>clolor: red;<br>&#125;<br><span class="hljs-selector-class">.block__element</span> &#123;<br><span class="hljs-attribute">color</span>: green;<br>&#125;<br><span class="hljs-selector-class">.block--modifier</span> &#123;<br><span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>這種方法有兩個關鍵之處：</p><p>定義一個變量<code>$last-rule</code>，賦予變量值為<code>null</code>主要用來代表相同的前綴；<br>在B中通過<code>$last-rule:&amp;</code>來賦予新值也就代表了對應的綴。</p><p><code>**特別聲明：採用這種方法，編譯的時候會提示警告信息，但並不會影響代碼**</code></p><p>編譯：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">Assigning <span class="hljs-selector-tag">to</span> global variable &quot;$last-rule&quot; by default is deprecated.<br>In future versions of Sass, this will create <span class="hljs-selector-tag">a</span> new local variable.<br>If you want <span class="hljs-selector-tag">to</span> assign <span class="hljs-selector-tag">to</span> the global variable, use &quot;$last-rule: &amp; !global<span class="hljs-string">&quot; instead.</span><br></code></pre></td></tr></table></figure><p>值得慶幸的是，在Sass的測試版本中有一個新的功能<code>@at-root</code>。</p><p>使用他配合<code>#&#123;&amp;&#125;</code>可以輕鬆的解決這個問題。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sass">.block &#123;<br>color: red;<br>@at-root #&#123;&amp;&#125;__element&#123;<br>    color: green;<br>&#125;<br><br>@at-root #&#123;&amp;&#125;--modifier&#123;<br>    color: blue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>編譯出來的CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.block</span> &#123;<br>clolor: red;<br>&#125;<br><span class="hljs-selector-class">.block__element</span> &#123;<br><span class="hljs-attribute">color</span>: green;<br>&#125;<br><span class="hljs-selector-class">.block--modifier</span> &#123;<br><span class="hljs-attribute">color</span>: blue;<br>&#125;<br></code></pre></td></tr></table></figure><p>Sass中的連接符<code>&amp;</code>讓你在嵌套和插值的使用過程時，會讓你憂，會讓你喜。<br> 憂的是一不小心使用不對帶來錯誤，或者讓你的代碼變得冗餘。<br> 喜的是讓你控制選擇器變得更加的靈活。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>My first blog</title>
    <link href="/2023/09/19/20220819/"/>
    <url>/2023/09/19/20220819/</url>
    
    <content type="html"><![CDATA[<p>大家好! 我是<a href="https://github.com/naiomidaphne">Daphne</a>! </p><p>這是我學習網頁開發後第一次自己架設的部落格，也是我第一篇部落格，算是一個新的開始，未來有更多的文章分享給大家！</p><p>期待與大家多多交流囉！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在vue裡面methods跟computed分別是什麼？他們使用上有什麼差別？</title>
    <link href="/2023/09/19/20220908/"/>
    <url>/2023/09/19/20220908/</url>
    
    <content type="html"><![CDATA[<p>簡單來說:<br>Method 是一位凡事親力親為，任何事都願意做的人<br>Computed 是一位自私自利的人，只有跟自己有相關的事，他才願意做事，其餘的事情他一概不碰</p><p>當我們在做一筆資料做更新時：<br>Method 不管資料有沒有跟它有關係，它一律皆作業更新<br>Computed  資料跟它有相關，它才更新，以程式操作系統來說它會比較有效率</p><p>🦉 <em><strong><code>從作用機制上：</code></strong></em></p><ol><li><code>methods，watch 和computed 都是以函數為基礎的，但各自卻都不同</code></li><li><code>watch 和computed 都是以Vue 的依賴追踪機制為基礎的，當某一個數據發生變化的時候，所有依賴這個數據的“相關”數據“自動”發生變化，也就是自動調用相關的函數去實現數據的變動</code></li><li><code>對 methods：methods 裡面是用來定義函數的，它需要手動調用才能執行。 而不像watch 和computed 那樣，“自動執行”預先定義的函數，相比於watch / computed，methods 不處理數據邏輯關係，只提供可調用的函數</code></li></ol><p><em><strong><code>從性質上：</code></strong></em></p><ol><li><p><strong><code>methods函數</code></strong></p><p> <code>裡面定義的是，仍然需要去調用它。</code></p></li><li><p><strong><code>computed計算屬性</code></strong></p><p> <code>事實上和data 對象裡的數據屬性是同一類的（使用上）。</code></p></li><li><p><strong><code>watch：</code></strong></p><p> <code>類似於監聽機制+事件機制</code></p></li></ol><ul><li><p><strong><code>methods</code></strong></p><p>  Vue method是與 Vue 實例中關聯的對象。<br>  函數是被定義在method的事件中，當你需要使用執行某些指令含有<strong>v-on</strong>的元素來操作處理事件時，method語法有很大的作用。<br>  我們可以進一步調用method語法來定義函數的執行操作。</p><p>  <code>在methods 中定義語法</code><br>  我們可以使用 methods 屬性給Vue 定義語法，methods的基本語法：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">var vm = new Vue(&#123;<br>methods:&#123;<br> // 在此時定義語法，語法之間使用逗號作分隔<br>         語法名:function()&#123;&#125;<br>&#125;);<br></code></pre></td></tr></table></figure>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">methods:&#123;<br>show: function()&#123;<br>console.log(&quot;顯示内容&quot;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  <code>在語法中訪問屬性</code><br>  在 methods 方法中訪問 data 的數據，可以直接通過 this.属性名 的形式來訪問。</p><p>  例如：<br>  我們在 show 方法中，訪問 number 屬性，可以直接通過 this.number 形式訪問，其中 this 表示的就是Vue 實例對象：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript"><span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-keyword">return</span>&#123;</span><br><span class="language-javascript"><span class="hljs-attr">number</span>: <span class="hljs-number">100</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript"><span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript"><span class="hljs-attr">show</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">number</span>);</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>  如果是在Vue 構造函數外部，可以使用 vm.方法名 定義或調用方法，還可以通過 vm.$data.属性名 來訪問 data 中的數據。</p></li><li><p>computed 計算屬性</p><p><strong>計算屬性在處理一些複雜邏輯時是很有用的。</strong></p><ul><li>除非computed依存的變數內容有變，不然computed不會重新運算</li><li>只有在computed依存的變數改變時，computed才會重新計算／回傳結果</li><li>上述示範的<code>now()</code>永遠不會更新其回傳的內容，因為<code>now()</code>中的<code>Date.now()</code>並非reactive dependency</li></ul>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">computed: &#123;<br>  now () &#123;<br>    return Date.now()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>**<code>methods 與 computed 區別：</code></p><p>  <strong>用computed 屬性方法編寫的邏輯運算</strong>，在調用時直接將返回時areas 視為一個變量值就可使用，無需進行函數調用。computed 具有緩存功能，在系統剛運行的時候調用一次。只有隻有當計算結果發生變化才會被調用。例如，我們在長度框與寬度框更改值的時候每次更改computed 都會被調用一次，很浪費資源。</p><p>  <strong>用methods 方法編寫的邏輯運算</strong>，在調用時add() 一定要加“()”，methods 裡面寫的多位方法，調用方法一定要有（）。methods方法頁面剛加載時調用一次，以後只有被調用的時候才會被調用。我們在長度框和寬度框的值輸入完以後，點擊“+” methods 方法調用一次。這裡很明顯我們採用methods 會更節省資源。</p><p>  🦉 我們可以使用methods 來替代computed，效果上兩個都是一樣的，但是computed 是基於它的依賴緩存，只有相關依賴發生改變時才會重新取值。<br>  而使用methods ，在重新渲染的時候，函數總會重新調用執行。</p><p>  設計一個計算成績和的案例：</p>  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs html">**<span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>**<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">en</span>&quot;&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">UTF-8</span>&quot;&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">viewport</span>&quot; <span class="hljs-attr">content</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">width</span>=<span class="hljs-string">device-width,</span> <span class="hljs-attr">initial-scale</span>=<span class="hljs-string">1.0</span>&quot;&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">X-UA-Compatible</span>&quot; <span class="hljs-attr">content</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">ie</span>=<span class="hljs-string">edge</span>&quot;&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>計算屬性與監聽器<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>      *<span class="hljs-comment">&lt;!-- 引入Vue.js --&gt;</span>*<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">.</span>/<span class="hljs-attr">node_modules</span>/<span class="hljs-attr">vue</span>/<span class="hljs-attr">dist</span>/<span class="hljs-attr">vue.js</span>&quot;&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">app</span>&quot;&gt;</span><br>        數學：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">text</span>&quot; <span class="hljs-attr">v-model</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">mathScore</span>&quot;&gt;</span><br>        英文：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">text</span>&quot; <span class="hljs-attr">v-model</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">englishScore</span>&quot;&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>*<span class="hljs-comment">&lt;!-- 注意：調用methods的方法一定要加括號 --&gt;</span>*<br>        總分（methods方式）：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">text</span>&quot; <span class="hljs-attr">v-model</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">sumScore</span>()&quot;&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span>*<span class="hljs-comment">&lt;!-- 注意：調用computed裡面的方法不要加括號 --&gt;</span>*<br>        總分（computed，純get方式）：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">text</span>&quot; <span class="hljs-attr">v-model</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">sumScore1</span>&quot;&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>        總分（computed，get+set方式）：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">text</span>&quot; <span class="hljs-attr">v-model</span>**=<span class="hljs-string">**</span>&quot;<span class="hljs-attr">sumScore2</span>&quot;&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        **<span class="hljs-keyword">var</span>** vm **=** **<span class="hljs-keyword">new</span>** <span class="hljs-title class_">Vue</span>(&#123;</span><br><span class="language-javascript">            el**:** <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="language-javascript">            data**:** &#123;</span><br><span class="language-javascript">                mathScore**:** <span class="hljs-number">80</span>,</span><br><span class="language-javascript">                englishScore**:** <span class="hljs-number">60</span></span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            methods**:** &#123;</span><br><span class="language-javascript">                sumScore**:** **<span class="hljs-keyword">function</span>** () &#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;methods方式調用！&quot;</span>);</span><br><span class="language-javascript">                    **<span class="hljs-keyword">return</span>** (**<span class="hljs-variable language_">this</span>**.<span class="hljs-property">mathScore</span> **-** <span class="hljs-number">0</span>) **+** (**<span class="hljs-variable language_">this</span>**.<span class="hljs-property">englishScore</span> **-** <span class="hljs-number">0</span>);</span><br><span class="language-javascript">                &#125;</span><br><span class="language-javascript">            &#125;,</span><br><span class="language-javascript">            computed**:** &#123;</span><br><span class="language-javascript">                *<span class="hljs-comment">// 默認是純get方式，也是單項綁定*</span></span><br><span class="language-javascript">                sumScore1**:** **<span class="hljs-keyword">function</span>** () &#123;</span><br><span class="language-javascript">                    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;compute的純get方式調用&quot;</span>);</span><br><span class="language-javascript">                    **<span class="hljs-keyword">return</span>** (**<span class="hljs-variable language_">this</span>**.<span class="hljs-property">mathScore</span> **-** <span class="hljs-number">0</span>) **+** (**<span class="hljs-variable language_">this</span>**.<span class="hljs-property">englishScore</span> **-** <span class="hljs-number">0</span>);</span><br><span class="language-javascript">                &#125;,</span><br><span class="language-javascript">                *<span class="hljs-comment">// 採用get加set方式*</span></span><br><span class="language-javascript">                sumScore2**:** &#123;</span><br><span class="language-javascript">                    get**:** **<span class="hljs-keyword">function</span>** () &#123;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;compute的get方式調用&quot;</span>);</span><br><span class="language-javascript">                        **<span class="hljs-keyword">return</span>** (**<span class="hljs-variable language_">this</span>**.<span class="hljs-property">mathScore</span> **-** <span class="hljs-number">0</span>) **+** (**<span class="hljs-variable language_">this</span>**.<span class="hljs-property">englishScore</span> **-** <span class="hljs-number">0</span>);</span><br><span class="language-javascript">                    &#125;,</span><br><span class="language-javascript">                *<span class="hljs-comment">// 當在輸入框中更改了總分後，兩項成績就會分別取到新總分的平均值，從而實現雙向綁定*</span></span><br><span class="language-javascript">                    set**:** **<span class="hljs-keyword">function</span>** (newValue) &#123;</span><br><span class="language-javascript">                        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;compute的set方式調用&quot;</span>);</span><br><span class="language-javascript">                        **<span class="hljs-keyword">var</span>** avgScore **=** newValue **<span class="hljs-comment">/** 2;</span></span><br><span class="hljs-comment"><span class="language-javascript">                        **this**.mathScore **=** avgScore;</span></span><br><span class="hljs-comment"><span class="language-javascript">                        **this**.englishScore **=** avgScore;</span></span><br><span class="hljs-comment"><span class="language-javascript">                    &#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">                &#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">            &#125;</span></span><br><span class="hljs-comment"><span class="language-javascript">        &#125;)</span></span><br><span class="hljs-comment"><span class="language-javascript">    </span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><ol><li><em>調用方式不同</em><br>  computed直接以對象屬性方式調用，不需要加括號。<br>  而methods必須要函數執行才可以得到結果。</li><li><em>綁定方式不同</em><br>  methods與compute純get方式都是單向綁定，不可以更改輸入框中的值。<br>  compute的get與set方式是真正的雙向綁定。</li><li><em>是否存在緩存</em><br>  methods沒有緩存，調用相同的值計算還是會重新計算。<br>  competed有緩存，在值不變的情況下不會再次計算，而是直接使用緩存中的值。</li></ol></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>如何運用TodoMVC 架構將後端寫到前端的？</title>
    <link href="/2023/09/19/20220920/"/>
    <url>/2023/09/19/20220920/</url>
    
    <content type="html"><![CDATA[<p>就以生活中大家都使用的LINE通訊軟體為例。<br>Line 裡面有不同的主題呈現套件、有社群討論區、有LINE PAY功能、有LINE Today 新聞區…等等。　<br>然後你當使用不同的功能來設定按照它的指示操作後，即可呈現出你想要的效果，這樣就有每個人不同訂製化呈現出的LINE APP。<br>TodoMVC 就像是一個 Line APP。</p><p>這是一個知名的開源專案，我們可以透過熟悉 Vue.js 、React 的基本語法、web component 的基本概念，並且熟悉 Vue.js 、React 的專案開發流程，從 CodePen 的環境過渡到本地開發環境。</p><p>TodoMVC 可以在用各種框架實現TodoList的增、刪、改、查功能，麻雀雖小，五臟俱全，是提供給大家學習、練習、再學習的最好範本。</p><ul><li><p><code>我們先來了解何謂 「MVC架構」</code></p><p>  🦉 <strong>Model</strong>：後端資料庫進行運作<br>  <strong>View</strong>：前端畫面與邏輯顯示<br>  <strong>Controller</strong>：處理控制流程和回應，以路由以傳遞資料為主&#96;</p><p>  模型檢視控制器 (Model-View-Controller，MVC)， 這三個套用在 Web 分別為前端 HTML+CSS(View)，後端 API 資料庫(Model)，控制後端資料庫的接口 JavaScript (Controller)</p><pre><code class="hljs">模型檢視控制器 (Model-View-Controller，MVC)， 這三個套用在 Web 分別為前端 HTML+CSS(View)，後端 API 資料庫(Model)，控制後端資料庫的接口 JavaScript (Controller)</code></pre><p>  　MVC 是許多開發人員熟悉的標準設計模式。有些類型的 Web 應用程式將受益於 MVC 架構。 有些則繼續使用仰賴 Web Form 和回傳的傳統 ASP.NET 應用程式模式。 還有一些類型的 Web 應用程式將合併兩種方式；兩種方式並不互斥。</p><ul><li><p><strong>模型(Model)  —  邏輯層</strong><br>  Model 主要管理與資料邏輯有關的事項，若使用者想要對資料進行「新增、修改、刪除、瀏覽」的動作，都需要透過 Model 中的 JavaScript 來操作，如電商網站的免運費、計算訂單總額…等等。<br>  ****模型物件是實作應用程式資料欄邏輯的應用程式部分。 通常，模型物件會擷取和儲存資料庫中的模型狀態。<br>  例如：Product 物件可能會從資料庫擷取資訊、操作它，然後將更新的資訊寫回SQL Server中的 Products 資料表。<br>  在小型應用程式中，模型通常是概念上的分隔而不是實體分隔。<br>  例如，如果應用程式唯讀取資料集並將它傳送至檢視，則應用程式沒有實體模型層和相關聯的類別。 在此情況下，資料集會採用模型物件的角色。</p></li><li><p><strong>介面檢視(View) —  表現層</strong><br>  View 主要管理第一線與使用者互動的介面，也就是 HTML 樣板，若是動態網站，他則會依照 Model 取出的資料內容，動態呈現使用者需要的網頁內容。<br>  ****View是顯示應用程式使用者介面的元件， (UI) 。 通常此 UI 是從模型資料建立。<br>  例如，Products 資料表的編輯檢視會根據 Products 物件的目前狀態顯示文字方塊、下拉式清單和核取方塊。</p></li><li><p><strong>事件控制器(Controller) —  事件層</strong><br>  Controller 是整個運作過程中的核心，掌握與瀏覽器之間的互動行為，也負責收發 Request 與 Response，因此，通常會在 Controller 設置不同的事件 Event，進而觸發不同指令完成後續動作。<br>  ****可以處理使用者互動、使用模型並且在最後選擇可以轉譯要顯示 UI的檢視。在 MVC 應用程式中，檢視只會顯示資訊，而控制器則會處理及回應使用者輸入和互動。<br>  例如：控制器會處理查詢字串值，並將這些值傳遞至模型，接著會使用值來查詢資料庫。當 Controller 收到請求後，Controller 會通知 Model 調度資料，接著再把資料傳遞給 View 來產生樣板，最終將呈現資料的 HTML 頁面回傳到客戶端的瀏覽器。</p></li></ul><p>  　MVC 模式可幫助您建立分隔應用程式不同方面 (輸入邏輯、商務邏輯和 UI 邏輯) 的應用程式，同時在這些項目之間提供鬆散的結合。<br>  此模式會指定每一種邏輯必須出現在應用程式中的位置。 UI 邏輯位於檢視，輸入邏輯位於控制器， 商務邏輯則位於模型。 此分隔可幫助您在建置應用程式時管理複雜性，因為它可讓您一次專注於實作的一個方面。<br>  例如，您可以專注在檢視上，而不需倚賴商務邏輯。</p><p>  💁🏻 <code>邏輯小測驗:</code></p><p>  <em><strong>1.MVC與 API差異？</strong></em></p><p>  Ans: MVC是個架構，之下可透過RESTful API 進行資料存取、方便管理路由及API</p><p>  <em><strong>2. React 是 MVC架構嗎？</strong></em></p><p>  Ans:  React 應該是只有V，因為到資料庫存取資料仍是透過node.js。</p><p>  <em><strong>3. 但是加入了 Redux 應該也可以算是 MVC 架構？</strong></em></p><p>  Ans:  React扮演的是View的角色，Redux 則是Controller，至於Model就是Redux Store中儲存的State。</p><p>  <em><strong>4. node.js express 框架比較符合 MVC？</strong></em></p><p>  Ans:  Client透過路由發送請求controller，路由到資料庫拿資料model，將資料output 到views ejs 樣板選染畫面給client。</p><p>  🦔 <strong><code>參考資料</code></strong></p><p>  <a href="https://tw.alphacamp.co/blog/mvc-model-view-controller">MVC架構是什麼？認識 Model-View-Controller 軟體設計模式｜ALPHA Camp Blog</a></p><p>  <a href="https://iter01.com/70995.html">基於 MVC 理解 React+Redux</a>  </p></li><li><p><code>**以前的工程師是如何使用MVC架構完成進行全端開發的?**</code></p><p>  使用 Express.js 框架進行全端開發，也就是運用 MVC 架構，一口氣從後端寫到前端，用這樣的方式完成了一個又一個的 app。</p><p>  然而，在實際開發的場景，愈來愈不太可能看見一個人打全場，或一個工具套全部的狀況，後端工程師、前端工程師、甚至 UI 設計師會共同合作完成產品，視專案的規模，說不定還會把資料庫與 API 分拆成不同的團隊處理。</p><p>  這件事被稱為「前後分離 (separate frontend from backend)」，在解釋前後分離的概念之前，我們先簡單回顧一下「前端」的發展簡史，才能瞭解「前端框架」是在什麼樣的背景下產生的。</p></li><li><p><strong><code>該如何使用TodoMVC架構來進行全端開發呢?</code></strong></p><h3 id="什麼是TodoMVC"><a href="#什麼是TodoMVC" class="headerlink" title="什麼是TodoMVC ?"></a><code>什麼是TodoMVC ?</code></h3><p>  TodoMVC 是一個協助網頁應用程式開發者挑選 MVC 架構工具，透過範例程式讓你可以很快的比較各種架構之間實質上的差異所在。</p><p>  拜網路雲端化的趨勢所賜，全世界有非常多的開發者陸續發展出非常多適用於網頁應用程式的 MVC<br>  架構（framework），其中更有許多優質的開放原始碼架構，無論是功能性與穩定性都非常好，網頁開發者可以利用這些豐富又免費的資源開發各種應用程式，省去自己設計架構的精力與時間。</p><p>  <code>**TodoMVC 網站**</code></p><p>  <a href="https://todomvc.com/">TodoMVC</a></p><p>  但是由於這樣的 MVC 架構實作品實在太多了，如何從中挑選一個適合自己的架構，又是一個令人頭痛的問題，有時後光去蒐集這類的資訊就已經很費時了，更何況還要消化它們。</p><p>  TodoMVC 將各種常見的網頁 MVC 架構整理出來，並且使用每一個架構實作一個 Todo List 示範程式，開發者可以從這些示範程式的原始碼很快的（應該說比起自己看各種官方網站要快一些）看出每個 MVC 架構的特性與差異，幫助開發者選擇適合自己專案的架構。</p><p>  如果以一個網頁應用程式的開發者的角度，強烈建議一定要參考一下這個網站，你可能聽過 Backbone.js、AngularJS 與 Ember.js，但是你可能不知道類似的架構常見的就有數十種，如果你要的東西別人已經寫好了，直接拿來用是可以輕鬆很多的。</p><p>  TodoMVC 將各種架構區分為 JavaScript Apps、Compile To JavaScript、MVC Extension Frameworks、Module Loaders 與 Real-time 這幾類，對於有興趣的架構你可以直接動手修改 GitHub 上的原始碼，感覺一下架構是如何運作的，我想這是一般的開發者在學習一個新技術時常會做的事情。</p><p>  另外 TodoMVC 也蒐集了每一種架構的一些網路資源（例如官方文件、社群的教學文件與討論區等），方便開發者查閱，使用起來很方便。</p><p>  💁🏻 **主要學習的目的：<br>  快速認識基本語法<br>  理解在框架裡寫前端，與過去的方式有何不同</p><p>  理解「網站組件化」的概念<br>  透過 Vue Component 或 React 實作來理解組件之間如何傳遞資料，以及傳遞資料時會涉及哪些議題</p><p>  實作一個 SPA 網站<br>  在本機建立開發環境<br>  建立 Component 並設定網站邏輯<br>  體驗開發與 debug 的流程<br>  處理 Routing 和 Model 的對應</p><p>  串接後端 API<br>  體驗什麼是前後分離**</p><p>  🦔 <code>**參考資料**</code></p><p>  <a href="https://xstate.js.org/docs/examples/todomvc.html#todomvc-with-react">TodoMVC Examples | XState Docs</a></p><p>  <a href="https://v2.vuejs.org/v2/examples/todomvc.html">TodoMVC - Vue.js</a></p></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
